#pragma kernel CSMain

//#pragma multi_compile RAYMARCH_DEBUG_ENABLED

#include "Packages/com.davidkimighty.rayman/Shaders/Library/Core/Math.hlsl"
#include "Packages/com.davidkimighty.rayman/Shaders/Library/Core/SDF.hlsl"
#include "Packages/com.davidkimighty.rayman/Shaders/Library/Core/Operation.hlsl"
#include "Packages/com.davidkimighty.rayman/Shaders/Library/Core/Raymarch.hlsl"

struct Shape
{
    int groupId;
    int id;
    float4x4 transform;
    float3 lossyScale;
    int type;
    float3 size;
    float roundness;
    int combination;
    float smoothness;
};

struct RaymarchResult
{
    float3 hitPoint;
    float travelDistance;
    float lastHitDistance;
    float3 debugColor;
};

float screenWidth;
float screenHeight;
float4 cameraPosition;
float4x4 cameraToWorld;
float4x4 inverseProjectionMatrix;
float4x4 viewProjectionMatrix;

int raymarchMaxSteps;
int raymarchMaxDistance;

int shapeCount;
StructuredBuffer<Shape> shapeBuffer;
RWStructuredBuffer<RaymarchResult> resultBuffer;
#if RAYMARCH_DEBUG_ENABLED
RWTexture2D<float4> resultTexture;
#endif

inline float BlendDistance(inout float totalDist, const float3 pos, const Shape shape)
{
    float dist = GetShapeSDF(pos, shape.type, shape.size, shape.roundness);
    float blend = 0;
    totalDist = CombineShapes(totalDist, dist, shape.combination, shape.smoothness, blend);
    return blend;
}

inline float Map(const float3 rayPos)
{
    float totalDist = raymarchMaxDistance;
    for (int i = 0; i < shapeCount; i++)
    {
        Shape shape = shapeBuffer[i];
        //float3 pos = NormalizeScale(ApplyMatrix(rayPos, shape.transform), shape.lossyScale);
        float3 pos = ApplyMatrix(rayPos, shape.transform);
        BlendDistance(totalDist, pos, shape);
    }
    return totalDist;
}

inline float NormalMap(const float3 rayPos)
{
    float totalDist = raymarchMaxDistance;
    for (int i = 0; i < shapeCount; i++)
    {
        Shape shape = shapeBuffer[i];
        //float3 pos = NormalizeScale(ApplyMatrix(rayPos, shape.transform), shape.lossyScale);
        float3 pos = ApplyMatrix(rayPos, shape.transform);
        BlendDistance(totalDist, pos, shape);
    }
    return totalDist;
}

[numthreads(16,16,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    const float2 uv = float2(id.xy) / float2(screenWidth, screenHeight);
    const float2 ndc = uv * 2.0 - 1.0;

    const float4 posCS = float4(ndc, 0.0, 1.0);
    float4 posVS = mul(inverseProjectionMatrix, posCS);
    posVS /= posVS.w;
    // float4 posWS = mul(cameraToWorld, posVS);
    // float3 rayDirWS = normalize(posWS.xyz - cameraPosition.xyz);
    float3 rayDir = normalize(posVS.xyz);
    float3 rayDirWS = normalize(mul((float3x3)cameraToWorld, rayDir));
    
    Ray ray = CreateRay(cameraPosition.xyz, rayDirWS, raymarchMaxSteps, raymarchMaxDistance);
#if RAYMARCH_DEBUG_ENABLED
    if (!Raymarch(ray))
    {
        resultTexture[id.xy] = float4(0, 0, 0, 0);
        return;
    }
    resultTexture[id.xy] = float4(ndc, 0, 1);
#else
    Raymarch(ray);

    RaymarchResult result = (RaymarchResult)0;
    result.hitPoint = ray.hitPoint;
    result.travelDistance = ray.travelDistance;
    result.lastHitDistance = ray.lastHitDistance;
    result.debugColor = float3(ndc, 0);
    
    uint index = id.y * screenWidth + id.x;
    resultBuffer[index] = result;
#endif
    
    float depth = GetDepth(cameraPosition.xyz, viewProjectionMatrix);
}
